## JS 模块化
### 1. 不得不说的历史
#### 背景
JS本身的定位：简单的页面设计 - 页面的逻辑简单处理 + 表单提交以及基本动画
并无模块化 or 命名空间的概念

> JS的模块化需求日益增长

#### 幼年期：无模块化协调阶段
1. 开始需要在页面中增加一些不同的JS：动画、表单、格式化工具
2. 多种js文件被分在不同的文件当中
3. 不同的文件被同一个模块所引用

```js
// index.html
<script src="animation.js"></script>
<script src="mian.js"></script>
<script src="tool.js"></script>
```
认可：
文件分离最基础的模块化，第一步

* 追问：
script标签 - async | defer
```js
// 1. script - 加载 + 解析
// 默认阻塞模式 依赖优先级
<script src="main.js"></script>
// 异步模式 - async   无优先级的大文件
<script src="main.js" async></script>
// 延迟模式 - defer  优先级较低的模块
<script src="main.js" defer></script>
```

问题出现：
* 污染全局作用域 => 不利于大型项目的开发以及多人团队共建


#### 成长期： 模块化的雏形 - IIFE
* 在模块系统尚未成为标准之前，开发者常通过 IIFE 来实现模块化。这种方式**主要通过函数作用域来封装代码**，避免污染全局作用域
例子：
```js
const myModule = (function() {
  const privateVar = 'this is private'
  return {
    getPrivateVar: function() {
      return privateVar
    }
  }
})()

console.log(myModule.getPrivateVar()) // this is private
```
定义函数 + 立即机型 => 独立的空间
初步实现了最最简单的模块
<br></br>

* 追问: **有额外依赖的时候，如何优化 IIFE**
> 优化： 依赖其他模块的IIFE(通过iife的参数来传递依赖)
```js
const iifeModule = ((dependencyModule1, dependencyModule2) => {
  let count = 0

  const obj = {
    increase: () => ++count,
    reset: () => {
        count = 0
    }
  }
  // ...dependencyModule1.xxx, dependencyModule2.xxx
  return obj
})(dependencyModule1, dependencyModule2)
```
* 追问 面试后序引导方向：
    深入模块化的多种方案
    转向框架 - jquery vue react
    转向设计模式 - 注重模块化的设计模式


#### 成熟期
##### CJS - CommonJS
> node.js 指定和推出的
特征：
* 通过module.export 去对外暴露接口
* 通过require来调用其他模块

模块组织方式：
```js
// 引入部分
const dependencyModule1 = require('.dependencyModule1')
const dependencyModule2 = require('.dependencyModule2')

// 核心逻辑
let count = 0

const increase = () => ++count
const reset = () => {
    count = 0
}
const obj = {
    test: 0
}
// ...dependencyModule1.xxx, dependencyModule2.xxx

// 导出模块
module.exports = {
    increase,
    reset,
    obj
}
```

> CJS导出变量的特点
* 另外需要说明的是，**cjs导出的变量相当于浅拷贝**
* 如果导出的是原始值，那么外部修改这个值，不会影响到原模块中的值
* 但是如果导出的是引用类型的值，那么外部修改这个变量，会影响到原模块中的值
* 另外之所以说它只是类似于浅拷贝，是因为在CJS模块西涌至，模块的加载和缓存机制也会对这种行为产生影响
<br></br>

原模块：
```js
let count = 1
let obj = {
  name: 'xxx'
}

function showCount() {
  console.log('原始模块count', count) 
}

function showName() {
  console.log('原始模块name', obj.name)
}
module.exports = {count, obj, showCount, showName}
```
外部模块：
```js
const module1 = require('./cjs1.js')

console.log(`原始模块原始值: ${module1.count}`) // 1
console.log(`原始模块引用值值: ${module1.obj.name}`) // xxx

// 改变原始值
module1.count = 10
// 改变引用值
module1.obj.name = 'changed'

console.log(`当前模块的count: ${module1.count}`) // 2
// 原始模块的count
module1.showCount() // 1

console.log(`当前模块的name: ${module1.obj.name}`) // change
// 原始模块的name
module1.showName() // change
```

> nodejs中，commonjs是默认的模块化系统，但在浏览器中需要使用打包工具（如Browserify、Webpack）来实现模块化。
* CJS优点： CJS率先在服务端实现了从架构层面解决依赖、全局变量污染的问题
* CJS缺点：针对服务端，**对于异步场景没有很友好地处理和考虑**

#### AMD
> 通过异步加载 + 允许定制回调函数 - require.js

特征：
```js
// 通过define来定义模块
define(id, [depends], callback)

require([module], callback)
define(
    'amdModule',
    ['dependencyModule1', 'dependencyModule2'],
    (dependencyModule1, dependencyModule2) => {
        // 业务逻辑
        let count = 0
        const increase = () => ++count
        // ...dependencyModule1
        if (env.a === 'module') {
            // dependencyModule2
        }
    }
)
require(['amdModule'], amdModule => {
    amdModule.increase()
})
```

* 面试题：手写一个函数，兼容判断AMD & CJS 
* define => amd 
* CJS => module.exports
* UMD
```js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD 环境，使用 define 定义模块
        define([], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS 环境，使用 module.exports 导出模块
        module.exports = factory();
    } else {
        // 浏览器全局环境，将模块挂载到全局对象上
        root.myModule = factory();
    }
}(typeof self !== 'undefined' ? self : this, function () {
    // 模块的实际内容
    function myFunction() {
        return 'Hello, world!';
    }

    // 返回要暴露的模块内容
    return {
        myFunction
    };
}));
```
* 优点：AMD解决了浏览器中异步加载模块的问题
* 缺点：没有实现按需加载

#### CMD工具框架 -sea.js
> 按需加载
```js
define('module', (require, exports, module) => {
    let $ = require('jquery')
    // ...
    let dependencyModule1 = require('./dependencyModule1')
    // ...
})
```
> 优点：按需加载，依赖就近，性能和谐 
> 缺憾：依赖于打包，加载逻辑会实际打包到模块中，增加了模块体积


#### ESM - es6
> 新增定义： 
> 引入关键字 - import
> 导出 - export
```js
import dependencyModule1 from './dependencyModule1.js'
import dependencyModule2 from './dependencyModule2.js'

// 业务逻辑
let count = 0
const increase = () => ++count
// ...dependencyModule1

export default {
    increase
}
```


* 面试方向：
* 1、工程化
* 2、ES
