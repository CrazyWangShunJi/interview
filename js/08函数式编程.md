# 函数式
## 1、函数式编程的出现
* 发展历程： 命令(脚本)式 => 面向对象式 => 函数式编程

#### 1.1 问题的出现 - 从一道面试题开始
```js
// 面试
// 1. 目标数组
// ['progressive$%coding', 'objective$%coding', 'functional$%coding']
// 2、转换成以下数组对象
// [{name: 'Progressive Coding'}, {name: 'Objective Coding'}, {name: 'Functional Coding'}]
// 命令式编程
const _array = ['progressive$%coding', 'objective$%coding', 'functional$%coding']
const _objArr = []

const parser = (array, objArr) => {
  array.forEach((item) => {
    let namesArr = item.split('$%')
    let newNameArr = []

    namesArr.forEach((name) => {
      let nameItem = name[0].toUpperCase() + name.slice(1) // 首字母大写
      newNameArr.push(nameItem)
    })

    objArr.push({
      name: newNameArr.join(' '),
    })
  })

  return objArr
}

// 问题
// 1、可读性：过程中存在大量的包裹逻辑 - 看完整代码才能明白在做什么
// 2、存在跨包裹的临时变量，首尾封闭 - 迭代拓展难度高
```

#### 1.2 解决方案 函数式编程
* 先拆解到一个一个的函数，再组合起来
```js
// 函数式编程
const _array = ['progressive$%coding', 'objective$%coding', 'functional$%coding']

// 函数 upperStr 字符串转化为首字母大写
const upperStr = (str) => str[0].toUpperCase() + str.slice(1)

// 先将字符串拆分成数组
// 再遍历数组，将数组中的字符串首字符大写
// 再组装数组成字符串
const reformatName = (str) => str.split('$%').map(item => upperStr(item)).join(' ')

// 将字符串转化为对象
const assembleObj = (key, value) => {
  let obj = {}
  obj[key] = value
  return obj
}

// 组合函数，实现功能
// 先遍历数组，调用reformatName将数组中的字符串转化为首字母大写
// 再调用assembleObj将字符串转化为对象
const paserArr = (arr) => arr.map((item) => assembleObj('name', reformatName(item)))
```

## 2、函数式编程原理
#### 2.1 什么式函数式原理
* 加法结合律 | 因式分解 | 完全平方公式 => 源自组合的变化 a + b + c = (a + b) + c
* 函数式编程通过**组合**函数来操作数据

#### 2.2 定义
* 什么是函数 —— 一等公民
* 声明式编程 => 关注做什么，而非怎么做, 更贴近语言习惯
* 惰性执行: 实现函数分流
```js
const program = name => {
  if (name === 'progressive') { 
    return program = () => {
      console.log('this is progressive')
    }
  } else if (name = 'objective') {
    return program = () => {
      console.log('this is objective')
    }
  } else {
    return program = () => {
      console.log('this is functional')
    }
  }
}

program('prograssive')()
```
* 无状态和无副作用
* * 无状态 - 幂等（当前给到的函数的执行结果和执行次数无关） - 不可以操作改变数据源
* * 无副作用 - 函数内部不应该直接对整个系统中任何参数变量做改动

#### 2.3 实际开发
* 1 纯函数的改造
```js
const _class = {
  name: 'objective'
  age: 17
}

// 以下是非纯函数，因为它在函数内部使用了外部的全局变量
// 不满足无副作用
const score = str => _class.name = str

// 以下也是非函数，只要执行一次，就会改变class
// 不满足无状态
const changeScore = (_class) => _class.age++

// 以下是纯函数
const newScore = (_class, str) => _class.name + str
const newchangeScore = (_class) => {
  let a = _class.age
  return a++
}
```

* 2、加工和组装函数
* 加工 - 柯里化
* 要实现 体系 = 加工 + 组装，当个模块加工输入输出应该单值化 => 单元函数
```js
  // f(x,y,z) => f(x)(y)(z)
  const sum = (x,y) => {
    return x + y
  }
  sum(1, 2)

  const add = (x) => {
    return (y) => {
      x + y
    }
  }
  add(1)(2)
```

* 面试题 手写构造可拆分传参的累加函数
add(1)(2)(3)(4) 实现累加效果
```js
// 1 构造柯里化结构 =》 函数的封装
// 2 输入 处理外层arguments =》 类数组处理
// 3 传入的参数无限拓展 =》 递归 =》 返回递归函数本身
// 4 主功能区 =》 累加
// 5 输出 =》 toSting

const add = () => {
  // input
  let args = Array.prototype.slice.call(arguments)

  // n内层 - 递归 + 参数手机
  let inner = () => {
    args.push(...arguments)
    return inner
  }
  
  // 外层 - 主功能区
  inner.toString = () => {
    return args.reduce((a, b) => a + b)
  }

  return inner
}

'' + add(1)(2)(3)(4)
```

* 组装函数
```js
const compose = (f,g) => x => f(g(x))

const sum1 => x + 1
const sum2 => x + 2 
const sum12 => compose(sum1, sum2)

// 实际实现
// 命令式
trim(reverse(toUpperCase(map(arr))))

// 面向对象
arrObjInstance.map().toUpperCase().reverse().trim()

// 函数时
const result = compose(trim, reverse, toUpperCase)

// Ramda - R
```