## typescript 详解
### 一、ts基础概念
#### 1、什么是ts
a. 对比原理
* 它是js的一个超集，在原有的语法基础上，添加了可选静态类型和基于类的面向对象编程
> 面向项目
TS - 面向解决大型复杂项目的，架构以及代码维护较为复杂
JS - 脚本化语言，用于面向简单页面场景

> 自主检测
TS - 编译时，主动发现并纠正错误
JS - 运行时报错

> 类型检测
TS - 弱类型，支持类型检测，并且可以进行编译时提示
JS - 弱类型 无静态类型选项
（强类型和弱类型的判断的分水岭是，是否存在隐式转换

> 运行流程
TS - 依赖编译，依靠编译打包实现浏览器的运行
JS - 可以直接在浏览器中运行
<br></br>

b. 安装运行
```js
npm i -g typescript
tsc -v
tec xxx.ts // 此时并没有真正的去执行这个文件中代码
// 面试点：所有的类型检测和纠错阶段 - 都是在编译时去做的
// 但是可以在编译时进行类型检测
```

#### 2 TS基础类型和写法
* boolean | string | number | array | null | undefined
```ts
// js
let isEnable = true
let course -= 'xx'
let num = 2
let u = undefined
let n = null
let classArr = ['basic', 'execute']

// ts
let isEnable: boolean = true
let course: string = 'xx'
let num:number = 2
let u: undefined = undefined
let n: null = null
let classArr1: string[] = ['basic', 'execute']
let classArr2: Array<string> = ['basic', 'execute']
```
<br></br>

* 元组 - tuple    元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同
```ts
let tupleType: [string, boolean]
tupleType = ['hello', true] // ok
tupleType = ['hello', true, 1] // 报错
```
<br></br>

* 枚举 - enum
```ts
// 默认数字类型枚举 - 默认从零开始，一依次递增
enum Score {
  BAD,
  NG,
  GOOOD,
  PERFECT,
}

let score: Score = Score.BAD
console.log(score) // 0

// 字符串类型
enum Score {
  BAD = 'BAD',
  NG = 'NG',
  GOOOD = 'GOOOD',
  PERFECT = 'PERFECT',
}

// 易构
enum Enum {
  A,        // 0
  B,        // 1
  C = 'c',  // c
  D = 'd',  // d
  E = 6,    // 6
  F,        // 7
}
```
<br></br>

* any | unknown | (void vs never)
* any 
```ts
// any - 绕过所有的类型检查
let anyType: any = 'hello'
anyType = 123
anyType = false

let value1: string = anyType // ok
let value2: number = anyType // ok
let value3: boolean = anyType // ok

// unkown - 绕过了赋值检查 => 禁止更改传递
// any和unkown都可以在声明阶段绕过类型检查，但是unknown禁止往下进行更改传递的
// 我们不能把unknown类型的变量赋值给其他的具有指定类型的变量
let unknownValue: unknown;
unknownValue = 1;
unknownValue = true;
unknownValue = 'xxxx'

let value1: unknown = unknownValue // ok
let value2: any = unknownValue // ok
let value3: string = unknownValue // 报错

// void - 声明函数的返回值为空
// void 表示没有任何类型，当一个函数没有返回值时，通常会见到其返回值是void
function fn():viod {
  console.log('no return')
}

// never - 声明函数永不返回
// never表示哪些用不存在值的类型，当一个函数抛出异常或无法正常执行的情况下，通常会见到其返回值是never
function error(msg: string): never {
 throw new Error(msg)
}

function longlongloop(): never {
  while(true) {
    console.log('never')
  }
}
```
<br></br>

* object | Object | {} - 对象
* object => 表示非原始类型的值，也就是除number，string，boolean，symbol，null或undefined之外的类型。

* Object => 是js中所有对象类型的顶级，其不仅仅表示非原始类型的值，还代表了原型对象上的属性Object.prototype
```ts
interface Object {
  constructor: Function;
  toSring(): sting
}
```

* {} - 空类型 => 没有元素成员的对象
* 当声明了这个空对象时。当对这个空对象做任何的属性相关的操作的时候，都会报错
```ts
let obj: {}
obj.a = 1 // error...
```
* 理论上它可以表示几乎任何非null和undefined的值
```ts
let value: {} = {}; // 空对象
value = 42;         // 合法，`42` 可以赋给 `{}` 类型
value = "hello";    // 合法，字符串也可以赋给 `{}` 类型
value = true;       // 合法，布尔值可以赋给 `{}` 类型
value = [];         // 合法，数组可以赋给 `{}` 类型
value = { a: 1 };   // 合法，带属性的对象也可以赋给 `{}` 类型

// value = null;    // 错误，null 不能赋给 `{}` 类型
// value = undefined; // 错误，undefined 不能赋给 `{}` 类型
```

### 二、接口 - interface
* 对行为的抽象，它内部不包含属性的值，而是对属性的描述
* 用来描述一个对象内部属性的内容
* 具体的行为由类来实现
```ts
interface Class {
  name: string,
  time: number
}

let zhaowa: Class = {
  name: 'ts',
  time: 2
}

// 1\ 只读 存在性
interface Class {
  readonly name: string,
  time?: number
}

// 面试题： readonly 和 js的引用不同const

// 2. 动态性 可添加
interface Class {
  readonly name : string,
  time?: number,
  [propName: string]: any
}

let obj: Class = {
  name: 'xxxx',
  wang: 23
}
```

### 三、交叉 - &
```ts
interface A {
  X: D
}

interface B {
  X: E
}

interface C {
  X: F
}

interface D { 
 d: boolean
}

interface E {
  e: string
}

interface F {
  f: number
}


// 交叉类型的联合
type ABC = A & B & C
let abx: ABC = {
  X : {
    d: true,
    e: '123',
    f: 123

  }
}
// 面试类型别名 - type vs interface
// 相同点： 都可以用来描述对象、函数, 并且都可以扩展(interface使用extends, type使用&)
interface Class {
  name: string
}
interface Course extends Class {
  score: number

}

type Class2 = {
  name: string
}
// 交叉联合
type Course2 = Class2 & {

}

type Course3 = {
  age: number
}

interface Class3 extends Course3 {
  score: number
}

// 不同点 - 
// 1、type 可以声明基本类型别名，联合类型，元祖等类型，interface 不行
// 联合计算
type nameClass = {
  name: string
}

type nickClass = {
  nickName: string
}

type UnionClasss = nameClass | nickClass

type TupleClass = [UnionClasss, nameClass]

// 2 interface通过多次定义来实现类型的集合
interface oldClass {
  name: string
}

interface oldClass {
  nickname: string
}

let newClass: oldClass = {
  name: '123',
  nickname: '123'
}


// 3. type 小能力
type Kyes = 'name' | 'nickName'

type oldClass2 = {
  [key in Kyes]: string
}

const zhaowa: oldClass = {
  name: '123',
  nickname: '123'
}


// 面试 ：联合冲突

interface G {
  c: string
  d: string
}

interface H {
  c: number
  e: number
}

type GH = G & H
let gh:GH = {
  c: '123', // 报错 ， 合并后c 变成了never
  d: '123',
  e: 123
}
```


### 四、断言
* 编译时的作用
```ts
// 尖括号声明
let anyValue: any = 'xxx'
let anyLength: number = (<string>anyValue).length

// as声明
let anyValue2: any = 'xxx'
let anyLength2: number = (anyValue2 as string).length

// 非空声明
type ClassTime = () => number

const start = (classTime: ClassTime | undefined) => {
  let num = classTime!() // 具体类型可能为多种，但是非空确认
}
```

### 五、类型守卫 - 保障语法的规定的多种范围之类，做校验，处理不同的流程
```ts
interface Teacher {
  name: string,
  courses: string[]
}

interface student {
  name: string,
  startTime: ''
}

type Class = Teacher | student;

function startCourse(cls: Class) {
  if ('courses' in cls) {
    console.log('teacher')
  } else {
    console.log('student')
  }
}
```

### 泛型
```ts
function startClass<T, U>(name: T, score:U): T {
  return (name + String(score)) as string as T
} 

startClass<string, number>('ts', 5)
```

### 装饰器
```ts
function zhaowa(target: Function): void {
  target.prototype.startClass = function(): void {

  }
}

function nameWrapper(target: any, key:string): void {
  Object.definedProperty(target, key, {
    
  }) 
}

// 类装饰器
@zhaowa
class Class {
  constructor() {
    // 业务逻辑
  }

  //属性装饰器
  @nameWrapper
  name: string
}
```