### ES - ECMAScript
ES6 & ESNext(指向真正成为规范的ES版本)

### 1、let const 声明
#### 1、不允许重复声明赋值
```js
var a = 'xxx'

// es5中实现常量功能
Object.defineProperty(window, 'a2', {
  value: 'xxx',
  writable: false,
})

// es6
const a3 = 'xxx'
```

#### 2、 块级作用域
* es5 var 存在变量提升
* es6 const let 取消变量提升 一定要先声明再使用
<br></br>

* es5 var 函数作用域 (在es5中使用立即执行函数来实现块级作用域)
* es6 const let 块级作用域
<br></br>

* 变量存在
* 在es5中，在全局作用域中使用var声明变量，变量挂载在window上
* 在es6中，使用const let 在全局作用域声明变量，变量不会挂载在window上
<br></br>

* dead zone
* 在es5中，使用var声明变量，在变量声明之前使用变量，会出现变量提升
* 在es6中，使用const let 声明变量，在变量声明之前使用变量，会出现dead zone
<br></br>

* let or const
* 为什么使用const 声明对象
* 对象是引用类型， const是保证引用的地址不变（地址存在栈中），但是引用的内容可以改变（内容存在堆中） 
<br></br>

* 面试：引用类型的原理 - 指向地址
* 引用类型的变量并不直接存储对象的值，而是存储对象的引用。
* 如果想要禁止修改对象的内容，可以使用Object.freeze(obj)
* **但是Object.freeze(obj)只能冻结对象的第一层属性，不能冻结对象的深层属性**
* 如果想要对引用类型的深层次全部冻结，只能使用递归
```js
function freezeObj(obj) {
  // 首先冻结当前属性
  Object.freeze(obj);
  
  (Object.keys(obj) || []).forEach((key) => {
    const value = obj[key]

    if (typeof value === 'object') {
      freezeObj(obj)
    }
  })

  return obj;
}
```

### 2、箭头函数
* 箭头函数出现的目的：
* 原来的函数比较复杂，既具有固有的函数的执行能力，还可以来表达一个构造对象等等
* 使用箭头函数就是原来的那部分纯粹的函数功能给剥离出来
* 另外一份的能力就是下面要讲到的 Class
* 1、this 绑定机制： 箭头函数不会绑定自己的this，而是继承外层作用域的this
* 在普通函数中，this 的值会根据调用者的上下文动态变化，而箭头函数的 this 始终指向声明时的上下文。
* 箭头函数不具备独立上下文 
* 面试中可能犯的菜哦做
```js
// 1\ dom操作，使用原生js改变按钮颜色
// 此时不能使用 箭头函数！
const btn = document.getElementById("btn");
btn.addEventListener('click', function() {
  this.style.color = "red";
})

// 2、类操作
// 这种情况不能使用箭头函数
// 箭头函数无法构造类
function Obj(Teacher, Course) {
  this.Teacher = Teacher
  this.Course = Course
}

const obj = new Obj('xxx', 'xxx')
```
<br></br>

* 2、箭头函数无法作为构造函数
* 上述中说到箭头函数没有自己的this   因此不能使用new 来实例化对象
* 也就是说箭头函数无法作为构造函数
<br></br>

* 3、没有prototype属性
* 由于箭头函数不能作为构造函数使用，因此它们也没有 prototype 属性
<br></br>

* 4、没有arguments
* 箭头函数没有自己的 arguments 对象，如果你在箭头函数中使用 arguments，**它会从外层函数（或者全局作用域）中继承**。如果你需要在箭头函数中处理参数列表，可以使用 rest 参数语法（...args）。
```js
const arrowFunction1 = () => {
    console.log(arguments); // ReferenceError: arguments is not defined
};

arrowFunction1(1, 2, 3);

function a() {
  const arrowFunction1 = () => {
    console.log(arguments); // [Arguments] { '0': [ 1, 2, 3 ] }
  };
  arrowFunction1()
}

a([1, 2, 3])

const arrowFunction2 = (...args) => {
    console.log(args); // 输出: [1, 2, 3]
};

arrowFunction2(1, 2, 3); // 输出: [1, 2, 3]
```

### 3、 Class 类
* **在es6以前，面向对象编程，是主要通过使用构造函数和原型继承来实现的**。
* **es6就推出了class 是对传统构造函数和原型继承的语法糖，所以class的类型也是function**
* **另外class便是使用extends和super来实现继承**
```js
// 传统对象 - function 来表达一个构造对象
function Course(teacher, course) {
  this.teacher = teacher
  this.course = course
}

Course.prototype.getTeacher = function () {
  return this.teacher
}

const course = new Course('张三', '语文')
console.log(course.getTeacher())

// ES6
class Course {
  // 构造器
  constructor(teacher, course) {
    this.teacher = teacher
    this.course =course
  }

  getCourse() {
    return this.course
  }
}
```

#### 面试题
* 1、class的类型是什么？
* function

* 2、class的prototype?
* 每个 JavaScript 类（class）实际上是一个函数，且每个函数都有一个 prototype 属性，指向该函数创建的所有实例共享的原型对象。这个原型对象上存放着该类定义的方法。

#### 属性的表达形式
* 1 get  set
* 实现只读
```js
class Type {
  constructor(teacher, course) {
    this._teacher = teacher
    this.course = course
  }

  getCourse() {
    return this.course
  }

  get teacher() {
    return this._teacher
  }

  // 实现只读
  // 不设置set
  /* set teacher(val) {
    this._teacher = val
  } */
}
const obj = new Type('张三', '语文')
console.log(obj.teacher)

obj.teacher = 1
console.log(obj.teacher)
```
<br></br>

* 2 实现私有属性
* **使用闭包的方式**
* 这样一来 外部只能通过某一个方法获取这个属性，而不能去修改
```js
class Type {
  constructor(teacher, course) {
    this._teacher = teacher
    
    let _course = '私有属性'

    this.getCourse = function () {
      return _course
    }
  }
}
```
* es10 后，通过# 来实现私有属性
```js
class Type {
  #course = '私有属性'
}
```
<br></br>

* 3 封装容器 - 适配器模式
* 底层封装业务core的中转模式
```js
class Utils {
  constructor(core) {
    this._mian = core
    this._name = "zhaowa"
  }

  set name(val) {
    this._name = val
  }

  get name() {
    return {
      ...this._mian.name,
      name: this._name
    }
  }
}
```

#### 静态方法 - 直接挂在类上，无需实例化获取
* static
```js
// ES5
function Course(teacher, course) {
  this.teacher = teacher
  this.course = course
}

Course.call = function() {
  console.log('call')
}

// es6
class Course {
  constructor(teacher, course) {
    this.teacher = teacher
    this.course = course
  }

  static call() {
    console.log('call');
  }
}
```

#### 继承
* extends & super
```js
class Course {
  constructor(teacher, course) {
    this.teacher = teacher
    this.course = course
  }

  send() {
    console.log('sneding');
  }

  static call() {
    console.log('calling')
  }
}

class Child extends Course {
  constructor() {
    super('yunying','math')
  }

  start() {
    console.log('starting');
  }
}

let course = new Course('xxx', 'yyy')

let child = new Child()
```

### 4、others
#### 1、解构

#### 2、proxy -- 代理
```js
// 以前的数据劫持方法
// 只能属性
let obj = {
  name: 'xxx'
}

Object.defineProperty(obj, 'name', {
  get() {},
  set() {}
})

// proxy 针对对象中的所有的值
let _proxy = new Proxy(obj, {
  get(target, key) {
    return target[key]
  },
  set(target, key, value) {
    target[key] = value
  }
})
```

#### 3、Reflect - 本质上是未来对于对象操作的主体
* 其实很多时候可以把reflect理解为对象Object
```js
```