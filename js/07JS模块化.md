> 本文主要讲到JS的模块化，其包含早期的IIFE以及后续CommonJs, AMD, CMD, ES6的模块化

# 1 IIFE
* 在模块化系统尚未形成标准之前，经常是使用IIFE来实现模块化
* 这种方式**主要通过函数作用域来封装代码**， 避免污染全局作用域
```js
const myModule = (function() {
  const privateVar = 'this is private'
  return {
    getPrivateVar: function() {
      return privateVar
    }
  }
})()

console.log(myModule.getPrivateVar()) // this is private
```
> 上面这种方式通过 定义函数 + 立即执行 => 形成了独立的空间
> 初步实现了最最简单的模块

# 2 CommonJs
* CommonJs是适用于服务端（nodejs）的模块化的规划

## 核心概念
* CommonJs是通过module.export和require来导入和导出模块中的内容
> 导出
```js
// math.js
const PI = 3.14159;

function add(x, y) {
    return x + y;
}

// 导出模块的内容
module.exports = { PI, add };

```

> 导入
```js
// main.js
const math = require('./math.js');

console.log(math.PI); // 输出 3.14159
console.log(math.add(2, 3)); // 输出 5
```

## 特点
### 同步加载
* CommonJS模块是同步加载的，在require()被调用时，模块就会立即加载
* 这就意味着，**只有当模块加载完成之后，后续的代码才会继续执行**。
* 这种设计适合服务端，因为服务器中的模块文件通常位于本地硬盘中，读取速度比较快
<br><br>

* 但是在浏览器端，由于网络延迟等原因，模块文件可能位于远程服务器上，读取速度较慢，因此同步加载的模式就不大适合后，这也是CommonJs的缺点

### 缓存
* 在CommonJS中，模块被首次加载之后会缓存，后续require()相同的模块时，返回的是缓存的实例，而不是重新加载模块。这就意味着模块只会加载一次，减少了不必要的重复操作

### 导出的值类似于浅拷贝
* 如果导出的是原始值，那么外部修改这个值，不会影响到原模块中的值
* 但是如果导出的是引用类型的值，那么外部修改这个变量，会影响到原模块中的值
* 相当于**浅拷贝**

> 之所以是类似于浅拷贝，是因为在 CommonJS 模块系统中，模块的加载和缓存机制也会对这种行为产生影响。
```js
let count = 1
let obj = {
  name: 'xxx'
}

function showCount() {
  console.log('原始模块count', count) 
}

function showName() {
  console.log('原始模块name', obj.name)
}
module.exports = {count, obj, showCount, showName}
```
外部模块：
```js
const module1 = require('./cjs1.js')

console.log(`原始模块原始值: ${module1.count}`) // 1
console.log(`原始模块引用值值: ${module1.obj.name}`) // xxx

// 改变原始值
module1.count = 10
// 改变引用值
module1.obj.name = 'changed'

console.log(`当前模块的count: ${module1.count}`) // 2
// 原始模块的count
module1.showCount() // 1

console.log(`当前模块的name: ${module1.obj.name}`) // change
// 原始模块的name
module1.showName() // change
```

## 优缺点
* 优点：
* * CommonJS率先从服务端实现了从架构层面解决依赖、全局变量污染的问题
<br></br>

* 缺点
* * CommonJS是同步加载的，对异步场景没有很好的考虑和处理，因此在浏览器端不支持
* * CommonJS是动态结构，只有执行后才知道引用什么样的模块，这样就不能通过静态分析去做优化，如tree-shaking等


# 3、AMD
> 上述讲到CommonJs是同步加载的，缺少异步处理机制
> 后续推出的AMD就解决了这一问题
* AMD 是一种用于浏览器端的 JavaScript 模块定义规范，主要目的是解决在浏览器环境中异步加载模块的问题。

## 模块定义和使用
* AMD使用define()函数来定义模块，define()函数接受两个参数
* * 第一个参数是依赖列表：一个数组，表示该模块依赖的其他的模块
* * 第二个参数是回调函数：在所有依赖都加载完毕之后，会调用该函数，并将依赖的模块作为参数传递给它
* 该回调函数返回模块的公开接口
<br></br>

* AMDs使用require()来加载和使用已经定义好的模块
* 它同样接受两个参数：依赖模块数组和回调函数。当依赖模块加载完成后，回调函数会被调用，并将依赖模块作为参数传入
<br></br>

* define()和require()都是异步加载所需要的依赖，
* 依赖的模块还未加载完成时，不会阻塞后续代码的执行。一旦依赖的模块加载完成，就会执行工厂函数来生成模块的定义。
```js
// main.js 定义模块
define(['dependency1', 'dependency2'], (dp1, dp2) => {
  // 使用dp1 和 dp2
  const myModule = {
    fn: () => {
      console.log('myModule')
    }
  }

  // 导出模块
  return myModule
})


// need.js 导入模块
require(['main'], main => {
  main.fn()
})
```
>优点：实现了异步加载
<br></br>

>缺点：不能按需加载，即，在define()或者require()中，在依赖列表里面指定的所有依赖都会被全部加载完，即使有些依赖可能在当前模块中不会被使用。这会导致代码冗余和性能问题。(而且AMD模块定义方式比较复杂，而且过度依赖回调函数，容易导致代码的嵌套层级增加，不适用于大型项目)


# 4、ESM(ES6 Module)
* ESM是ES6引入的一种新的模块系统，其通过 export 和 import 关键字来定义和加载模块。

## 基本使用
* export 用于变量的导出模块的内容。可以导出函数、变量、类等
* 其有两种导出方式
> 命名导出和默认导出
```js
// 命名导出
// 可以导出多个值，导入时通过名称访问
// moduleA.js
export const PI = 3.14159;
export function add(a, b) {
  return a + b;
}

var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export { firstName, lastName, year };

// 默认导出：每个模块只能有一个默认导出，使用 export default 关键字。
// moduleB.js
export default function calculateCircleArea(radius) {
  return Math.PI * radius * radius;
}
```

* import 用于导入模块的内容
```js
// 导入命名导出
// main.js
import { PI, add } from './math.js';
console.log(PI); // 3.14159
console.log(add(2, 3)); // 5

// 导入默认导出
// main.js
import calculateCircleArea from './calculate.js';
console.log(calculateCircleArea(10)); // 314.159

// 同时导入命名导出和默认导出
// main.js
import calculateCircleArea, { PI } from './calculate.js';
console.log(PI); // 3.14159
console.log(calculateCircleArea(10)); // 314.159

// 导入整个模块作为对象
// main.js
import * as math from './math.js';
console.log(math.PI); // 3.14159
console.log(math.add(2, 3)); // 5
```

## 特点
### 静态分析
* 在上文中讲到CommonJS是动态分析的，只有执行后才知道引用什么样的模块，这样就不能通过静态分析去做优化，如tree-shaking等
* 而ES6是静态分析，在编译时就知道了引用的模块，因此可以进行tree-shaking等优化

### 异步加载和按需加载
#### 默认情况下是**同步加载**的
* 如果直接使用import语法导入模块，加载过程就是静态同步的
* 也就是说ESM的依赖关系会在代码执行之前就被解析，模块会在编译阶段同步加载
> 在默认情况下，ESM尽管是同步加载的，但是它是还是静态同步的，支持静态分析
```js
// main.js
import { add } from './math.js';

console.log(add(2, 3));
```
* 在上面这个例子中，浏览器或 Node.js 在执行代码之前会同步加载 math.js 模块，确保所有依赖的模块在执行时已经加载完毕
<br>

#### 可以通过import()函数实现异步加载和按需加载
* ESM 也提供了一个支持异步加载模块的机制，即 import() 函数。
* **import()可以用于按需动态加载模块**
* import()返回的是一个**Promise**, 当模块加载完成后，Promise 会解析为模块对象。
```js
// main.js
async function loadModule() {
  const math = await import('./math.js'); // 返回一个Promise

  console.log(math.add(2, 3)); // 使用动态加载的模块
}

if (condition) {
  // 满足特定条件，按需动态异步加载
  loadModule();
}
```
> 也即是说静态import是同步的，动态import()是异步的


### export导出的是引用值
* 在上文中说到，CommonJS导出的是值的浅拷贝，如果值是原始值，在外部改变不会原模块的值，但是如果是引用值，在外部改变就会改变原模块的值
* 但是ESM导出的是引用值，在ESM中导入的变量会跟着导出的变动而变动。
```JS
// a.mjs
let a = 1;
let b = { num: 1 }
setTimeout(() => {
    a = 2;
    b = { num: 2 };
}, 200);
export {
    a,
    b,
};
 
// main.mjs
// node --experimental-modules main.mjs
import {a, b} from './a';
console.log(a);  // 1
console.log(b);  // { num: 1 }
setTimeout(() => {
    console.log(a);  // 2
    console.log(b);  // { num: 2 }
}, 500);
```