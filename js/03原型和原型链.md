# 1 原型 prototype 和 原型链
* 在javascript中，每个对象都有一个原型(prototype)。原型也是一个对象，它包含了共享属性和方法的定义

* 当我们创建一个对象时（比如通过构造函数），它的[[prototype]]通常会自动连接到其构造函数的prototype属性上。

* 我们可以通过__proto来查找原型
* 当我们访问一个对象obj的属性或者方法时，js会首先查找这个对象的自身的属性,
* 如果没有则通过**__proto__**查改该对象的原型, obj.__proto__
* 这个原型对象上没有，则继续顺着__proto向上查找，直到查找到**null**为止

* js查找属性规则
```js
function findProperty(obj, key) {
  if (obj.hasOwnProperty(key)) {
    return obj[key];
  }
  
  var __proto__ = obj.__proto__;

  while(__proto__) {
    if (__proto__.hasOwnProperty(key)) {
      return __proto__[key];
    }
    __proto__ = __proto__.__proto__;
  }

  return undefined;
}
```

# 2 题目
* 1. 假定我们的代码中需要4个类，分别是 Animal，Dog，Cat，Human。Animal 有方法 eat,sleep;Dog,Cat有方法bark；Human有方法speak；请使用js中的继承实现。
es6写法
```js
class Animal{
  eat() {
    console.log("Eating...");
  }
  sleep() {
    console.log("Sleeping...");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Barking...");
  }
}

class Cat extends Animal {
  bark() {
    console.log("Barking...");
  }
}

class Human {
  speak() {
    console.log("Speaking...");
  }
}

let cat = new Cat();
cat.eat();
cat.bark();
```

es5写法
```js
function Animal() {
  this.age = 1;
}
Animal.prototype.eat = function () {
  console.log("Eating...");
}

Animal.prototype.sleep = function () {
  console.log("sleep...");
}

function Dog() {}
Dog.prototype.bark = function () {
  console.log("bark...");
};
// 实现了继承 非完美 只能继承方法
Dog.prototype.__proto__ = Animal.prototype;

let dog = new Dog();
console.log(dog.age) // undefined

// 实现了完美继承 继承属性和方法
Dog.prototype.__proto__ = new Animal()

let dog2 = new Dog();
console.log(dog2.age) //1 
```