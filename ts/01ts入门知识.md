# TS
## 1、TS类型
* 在js中，一个变量可以被赋值为任意类型，后续也可以被赋值为任意其他类型
* 但是在ts中，当一个变量被首次赋值之后，它的类型就确定了，一般情况下不能再被赋值为其他类型
#### 原始类型
* 原始类型boolean | string | number | null | undefined
* ts中对于原始类型，采用 : 类型 的语法来实现
```ts
// ts中有以下原始类型，当其被首次确定后，后续都无法无法改变其类型
let isEnable: boolean = true
let course: string = 'xx'
let num:number = 2
let u: undefined = undefined
let n: null = null

n = 123 // 报错
```

#### 数组和元组
* 在ts中有两种方式可以描述一个数组类型
* 第一种在元素类型后面接上[], 以此表示此类型元素组成的一个数组
```ts
let strArr: string[] = ['a', 'b', 'c']

let numArr: number[] = [1, '2', 3] // 报错
```
<br></br>

* 第二种是使用数组泛型 Array<元素类型> 来展示
```ts
let classArr: Array<string> = ['basic', 'execute']
```
<br></br>

* 元组 - tuple 元组类型允许表示一个**已知元素数量和类型的数组**，各元素不必相同
```ts
let tupleArr: [string, number] = [ 'hello', 100]

let tupleArr: [string, number] = [ 100, 100] // 报错

let tupleArr: [string, number] = [ 'hello']
```

#### 枚举
* 使用enum定义
```ts
// 默认数字类型枚举 - 默认从零开始，一依次递增
enum Score {
  BAD,
  NG,
  GOOOD,
  PERFECT,
}

let score: Score = Score.BAD
console.log(score) // 0

// 字符串类型, 必须手动赋值
enum Score {
  BAD = 'BAD',
  NG = 'NG',
  GOOOD = 'GOOOD',
  PERFECT = 'PERFECT',
}

// 易构
enum Enum {
  A,        // 0
  B,        // 1
  C = 'c',  // c
  D = 'd',  // d
  E = 6,    // 6
  F,        // 7
}
```

#### any | unknown | void | never
* 当有时候还不清楚变量的类型时，可以使用any
* 使用any去指示变量的类型时，表示ts在声明阶段直接绕过该变量的类型检查
* 并且还可以进行传递，将其赋值给其他任意变量
```ts
let a: any = 1
a = 'xxx' // 绕过类型检查
a = true

let b: string = a // ok 并不报错  可以进行值的传递
```
* 因为any允许变量进行任意类型的操作，所以相对不安全
<br></br>

* unknown也允许在声明阶段直接绕过类型检查
* 但是ts禁止将unknown类型的变量直接赋值给其他其他指定类型的变量
* 只有当unknown类型的变量被明确某一类型的变量，或者进行类型断言后，才能进行安全使用
```ts
let un: unknown = 1
un = 'xxx' // ok 正常
un = 1234
/* let a: number = un // 报错 无法进行更改传递
let b: number = un // 报错 无法进行更改传递 */
 
if (typeof un === 'number') {
  console.log(un) // ok 正常 确定类型后可以安全使用
}

let c: string = (un as string) // ok 正常 使用类型断言绕过检查
console.log(c)
```
<br></br>

* void vs never
* void 表示一个空值，通常用于函数中，表示函数没有返回值
```ts
function fn():viod {
  console.log('no return')
}
```
* never 表示永远不存在值的类型
* 当一个函数抛出异常或无法正常执行的情况下，通常会见到其返回值是never
```ts
function error(msg: string): never {
 throw new Error(msg)
}

function longlongloop(): never {
  while(true) {
    console.log('never')
  }
}
```
<br></br>

#### obejct | Object | {}
* object => 表示非原始类型的值，也就是除number，string，boolean，symbol，null或undefined之外的类型。
```ts
let obj1: object = {a: 1}
obj1 = {a: 2}     // 可以是普通对象=
obj1 = [1, 2, 3]  // 可以是数组
obj1 = () => {}   // 可是是函数
obj1 = 42 // 报错，不能为原始类型
```
<br></br>

* Object => 是js中所有对象类型的顶级，相当于Object.prototype
* 在ts中可以看到这个接口的定义
```ts
  interface Object {
    constructor: Function;

    toString(): string;
    toLocaleString(): string;
    valueOf(): Object;
    hasOwnProperty(v: PropertyKey): boolean;
    isPrototypeOf(v: Object): boolean;
    propertyIsEnumerable(v: PropertyKey): boolean;
}
```
* 其不仅仅可以表示非原始类型的值，还可以表示所有的非null和undefined的原始类型的值
```ts
let obj1: Object = {a: 1}
obj1  = 1
obj1 = 'xxx'
obj1 = true
obj1 = []
obj1 = () => {}

obj1 = null // 报错
obj1 = undefined // 报错
```
<br></br>

* {} 表示一个空类型，是一个没有元素成员的对象
```ts
let obj = {};
// const obj: {}

obj.name = 'zxx';
// 类型“{}”上不存在属性“name”
```
* 理论上它可以表示几乎任何非null和undefined的值
```ts
let value: {} = {}; // 空对象
value = 42;         // 合法，`42` 可以赋给 `{}` 类型
value = "hello";    // 合法，字符串也可以赋给 `{}` 类型
value = true;       // 合法，布尔值可以赋给 `{}` 类型
value = [];         // 合法，数组可以赋给 `{}` 类型
value = { a: 1 };   // 合法，带属性的对象也可以赋给 `{}` 类型

// value = null;    // 错误，null 不能赋给 `{}` 类型
// value = undefined; // 错误，undefined 不能赋给 `{}` 类型
```
* 它在运行时与Object基本相同， 你可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用（访问Object.prototype原型对象上的属性）

## 2、接口 - interface
#### 基本用法
* 用来定义对象的结构
```ts
interface obj {
  name: string,
  age: number
}
const obj1: obj = {
  name: 'xx',
  age: 12
}
```
#### 可选属性
* 有时候接口中的属性不全部都是必须的，可以在属性名后面添加 **?** 表示可选属性
```ts
interface obj {
  name: string,
  age?: number
}
const obj1: obj = {
  name: 'xx',
}
```

#### 只读属性
* 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 **readonly** 来指定只读属性:
```ts
interface obj {
  name: string,
  readonly age: number
}
const obj1: obj = {
  name: 'xx',
  age: 12
}
obj1.name = 'yy'
obj1.age = 13 // 报错
```
<br></br>

* ts中也可使用ReadonlyArray<T>来保证数组不被修改
```ts
let arr: ReadonlyArray<number> = [1, 2, 3]
arr[1] = 5 // 报错
arr.pop() // 报错
```
<br></br>

* readonly vs const
* 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly

#### 动态添加
* 有时候创建一个对象时，希望它具有一些额外的属性，
* 可以使用 索引签名
```ts
interface Class {
  readonly name : string,
  time?: number,
  [propName: string]: any
}

let obj: Class = {
  name: 'xxxx',
  wang: 23
}
```

#### 定义 函数 | 数组
* 接口不仅仅可以定义普通对象类型，还可以定义函数、数组
* 像上诉动态添加的案例，我们同样可以使用**索引签名**定义 函数或者数组
* 定义函数
```ts
interface fn {
  (param1: string, param2: number): boolean;
}

let myFn: fn = function(s: string, n: number) {
  return true
}
```
<br></br>

* 定义数组
```ts
interface arr {
  [index: number]: string | number;
}

const newArr: arr = [1, 2, 3, 'xxx']
```

#### 接口继承
* 和类一样，接口也可以继承
```ts
interface obj1 {
  name: string
}

interface obj2 extends obj1{
  age: number
}

// 单次继承
let newObj: obj2 = {
  name: 'xxx',
  age: 123
}

interface obj3 {
  people: Array<number>
}

// 多次继承
interface mutipleObj extends obj3, obj2 {
  school: string
}

let newObj2: mutipleObj = {
  name: 'wsz',
  age: 12,
  people: [1,2,3],
  school: 'ooo'
}
```

#### 接口合并
* 当重复声明一个接口时，接口会被自动合并
```ts
interface obj1 {
  name: string
}

interface obj1 {
  age: number
}

let newObj: obj1 = {
  name: 'xxx',
  age: 18
}
```

## 3、类型别名 - type
* 上述说到了接口interface可以用于定义对象
* 我们也可以使用type来定义对象，而且type不仅仅可以定义对象，还可以定义一些基础类型
#### 基本用法: 定义 对象 | 数组 | 函数 | 基本类型
```ts
// 定义对象 
type obj1 = {
  a: number
  b: string
}
const newObj1: obj1 = {
  a: 1,
  b: 'xxx'
}

// 定义基本类型
type str = string
type num = number
const str1: str = 'xxx'
const num1: number = 122

// 定义数组
// 使用索引标签
type arrIndex = {
  [index: number] : number | string | boolean
}
const arr1: arrIndex = [1, 2, 3, 'xxx', true]
// 直接使用数组泛型
type arrGen = Array<number | string | boolean>
const arr2: arrGen = [1, 2, 3, 'xxx', true]
// 定义元组
type tuple = [number, string]

// 定义函数
type fn = (a: number, b: number) => number
const fn1: fn = (a, b) => a + b
// 同样，也可使用索引标签来定义
type fn2 = {
  (a: number, b: number): boolean
}
const fn2: fn2 = (a, b) => true
```

#### 只读属性 | 可选属性 | 属性动态添加
* 与interface类似，type也可以实现上述功能
* 实现方式也类似
```ts
// 定义对象 
type obj1 = {
  readonly a: number, // 只读
  b?: string, // 可选
  [key: string]: any // 动态添加
}
const newObj: obj1 = {
   a: 1,
   x: 2
}

newObj.a = 2 // 报错
```

#### 联合类型（ | ） 交叉类型 （&）
* 交叉类型 & 表示一个变量同时满足多个类型的要求
* **type没有继承，但是可以通过交叉类型来实现**
```ts
type obj1 = {
  name: string
}

type obj2 = obj1 & {
  age: number
}

const obj: obj2 = {
  name: 'xxx',
  age: 12
}
```
<br></br>

* 联合类型 | 表示一个变量可以满足多个类型中的一个
```ts
type obj1 = {
  name: string
}

type obj2 = obj1 | {
  age: number
  person: number
}

const o1: obj2 =  {
  name: 'xxx' // ok
}

const o2: obj2 = { // ok
  age: 12,
  person: 12
}

const o3: obj2 = { // 报错, 缺少person属性
  age: 1 
}

const o4: obj2 = { //ok
  name: 'xxx',
  age: 12,
}
```

#### 其他
* 1、注意： interface可以多次定义表示合并，但是type不能多次定义
* 2、注意：interface可以继承，但是type不可以继承，但是type可以使用交叉类型来实现继承的效果

## 4、类型断言
* 类型断言用于在编写代码时，手动指定一个值，而不是让编译器自动推断值的类型
* 一般有两种语法： 尖口号声明\<Type>value或者as声明value as Type
```ts
let someValue: unknown = "Hello, TypeScript!";

// 尖括号语法
let strLength: number = (<string>someValue).length;

// as 语法
let strLength2: number = (someValue as string).length;

console.log(strLength);  // 输出: 18
console.log(strLength2); // 输出: 18
```

#### 在dom操作中的应用
* 在操作 DOM 元素时，TypeScript 可能无法推断出元素的确切类型。这时可以使用类型断言
```ts
const inputElement = document.getElementById("myInput") as HTMLInputElement;

if (inputElement) {
  inputElement.value = "TypeScript is awesome!";
}
```


## 5、类型守卫
* 类型守卫（Type Guards）是 TypeScript 中的一种机制，用于在运行时对变量的类型进行检查，以确保变量在特定代码块中的类型。类型守卫帮助 TypeScript 了解在某个条件下变量的具体类型，从而提供更安全的类型推断。
```ts
interface Teacher {
  name: string,
  courses: string[]
}

interface student {
  name: string,
  startTime: ''
}

type Class = Teacher | student;

function startCourse(cls: Class) {
  if ('courses' in cls) {
    console.log('teacher')
  } else {
    console.log('student')
  }
}
```

## 6、泛型 - 类型参数
* 泛型本质上其实就是类型世界中的参数，类型参数
* 其通过 <> 来实现
* 开发者可以在定义函数、类 或者接口中 都可以使用类型参数，这样可以使代码更加灵活

#### 泛型类型别名
```ts
type Status<T> = 'success' | 'failure' | 'pending' | T

type CompleteStatus = Status<'offline'>

// 相当于
type CompleteStatus = 'success' | 'failure' | 'pending' | 'offline'
```
* 在上面这个例子中，Status就像一个函数，它声明了自己有一个参数T，并会将这个参数T合并到自己内部的联合类型中

##### 泛型函数
```ts
function fn<T, U>(name: T, score: U): T {
  if (typeof name === 'string') {
    return name
  } else {
    return {} as T
  }
}

fn<string, number>('xxx', 12)
```

#### 泛型接口
```ts
interface GenericIdentityFn<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;

console.log(myIdentity(10)); // 输出: 10
```
* 这里定义了一个泛型接口 GenericIdentityFn，它描述了一个函数类型，可以接受类型参数。

#### 泛型类
```ts
class Box<T> {
  private content: T;

  constructor(value: T) {
    this.content = value;
  }

  getContent(): T {
    return this.content;
  }
}

const numberBox = new Box<number>(123);
const stringBox = new Box<string>("Hello");

console.log(numberBox.getContent()); // 输出: 123
console.log(stringBox.getContent());  // 输出: Hello
```
* 在这个例子中，Box 是一个泛型类，使用类型参数 T 来指定 content 的类型。

#### 泛型约束
```ts
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): void {
  console.log(arg.length);
}

logLength({ length: 10, value: 20 }); // 合法
// logLength(42); // 错误，因为 number 没有 length 属性
```
* 在这个示例中，logLength 函数接受一个泛型参数 T，并确保 T 具有 length 属性。

## 7 装饰器
* 要启用装饰器，需要在 **tsconfig.json中启用experimentalDecorators**
* 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。
* 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。

#### 类装饰器
* 类装饰器在类声明之前被声明
* 装饰器应用于类构造函数，可以用来，监视、修改、或者替换类定义
* **类装饰器会在运行时被当作函数被调用，类的构造函数作为其唯一的参数**
```ts
function sealFn(target: Function): void {
  console.log(target) // [class Person]
  console.log(target.name) // 'Person'
  target.prototype.start = '我添加了一个新的原型属性'
}

@sealFn
class Person{
  constructor() {
    
  }
}

let peo1 = new Person()
console.log(Object.getPrototypeOf(peo1).start) // '我添加了一个新的原型属性'
```
<br></br>

* 关于类装饰器的返回值：
* 如果没有返回任何值，默认情况下，他会返回原始的构造函数
* 如果返回一个新的构造函数，原始类将被替换为这个新构造函数
* 返回一个继承的类：也可以返回以及继承自原始类型的新类

#### 属性装饰器
* 属性装饰器声明在一个属性声明之前
* 属性装饰表达式会在运行时当作函数被调用，传入以下两个参数
* 1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象
* 2、成员的名字
```ts
function Log(target: any, propertyKey: string) {
  console.log(`Property ${propertyKey} is created.`);
}

class Person {
  @Log
  name: string;

  constructor(name: string) {
    this.name = name;
  }
}

// 输出: Property name is created.
const person = new Person("Alice");
```
