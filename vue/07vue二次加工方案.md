# 1、watch 和 computed
* watch和computed尽管都可以监听数据的变化并作出反应，但是它们在使用场景、工作方式和内部原理上都有明显区别

### 使用上：
* watch: 主要用于监听某一响应式数据，并在发生变化时执行特定的回调函数
* 它适用于需要在数据发生变化时执行某种操作如发起异步请求等
* 逻辑上它是 一对多 监听一个响应式数据 然后进行一些操作
<br></br>

* computed: 主要用于依赖某些响应式数据来计算出新的值，它是一种懒计算，只有当依赖的数据发生变化时才会重新计算
* 也即 **computed具有缓存机制**
* 逻辑上它是 多对一 监听多个响应式数据 然后计算出一个新的响应式数据

### 原理上：
* watch: 直接对该响应式数据进行劫持监听，当响应式数据发生变化时，触发setter，然后再来触发相应的回调函数
<br></br>

* computed: 在使用computed来计算响应式数据时，它首先是在getter里面去收集它所有依赖的所有的响应式数据
* 当收集到的这些响应式数据发生变化时，才会重新计算该computed响应式数据
<br></br>

# 2、其他
* 方案1： 函数
```js
{{ calcAdd(xxx)}}
```
<br></br>

* 方案2： 管道符(过滤器)
```js
{{ xxx | calcAdd }}
```
<br></br>

* 方案3：指令  
* v-text  v-html
<br></br>

* 方案4：直給
* {{ ...三元表达式 js逻辑 数据计算 }}
<br></br>

* 方案5：jsx

## jsx 更自由的all in js
* 可以用来做更加灵活且js化的方案
* jsx: javascript XML
* 在渲染函数章节讲解