# 性能优化
面试 如何衡量页面的加载时间/如何评估页面加载
## 1、 衡量性能 -navigation timing API
* window.performance.timing 是一个Performance Timing 接口的属性
* Performance Timing 是浏览器提供的一组 API，用于测量和分析网页的加载性能。这些 API 允许开发者访问一系列时间戳，以便更好地理解页面加载过程中的各个阶段。
* 主要的时间戳有：
* navigationStart：用户开始导航到当前文档的时间（从 Unix 纪元时间算起）。
<br></br>

* unloadEventStart 和 unloadEventEnd：前置页面卸载的开始和结束时间。
> 面试：无前置页面？ => 值为0

> 前置页面不同域时?(如从淘宝跳到天猫) => 涉及到新域名的重新加载，是无法获取到前置页面卸载的时间点，所以值也为0（**即跨域跳转，浏览器不会触发unload事件**）
<br></br>

* redirectStart 和 redirectEnd：多重重定向的消费时间。
> 面试： redirectStart 实际上是第一次重定向的时间戳/ redirectEnd是最后一次重定向完成的时间戳
<br></br>

* fetchStart / End 准备好去使用http请求来抓取文档
<br></br>

* domainLookupStart 和 domainLookupEnd：DNS 查询开始和结束的时间。(重新建立连接的时间)
> 面试： 只是建立，请求还没有发出去

> 面试: 如果长连接  值等于fetchstart
<br></br>

* secureConnectionStart / End HTTPS 连接建立开始的时间

* connectStart 和 connectEnd：HTTP与服务器建立连接的开始和结束时间。
<br></br>


* requestStart / End 请求发起的真实时间 。
> 面试： 包含了本地缓存的读取（无论是强缓存还是协商缓存）
<br></br>

* responseStart 和 responseEnd：收到响应的开始和结束时间。
<br></br>

* domLoading 开始渲染解析DOM树 => readystatechange
* domInteractive 渲染dom树完成 => readystatechange
*  domComplete：整体DOM树的解析完成。
<br></br>

* loadEventStart 和 loadEventEnd：load 事件触发的开始和结束时间。
<br></br>


```html
<script>
  javascript: (() => {
    const timing = window.performance.timing
    // 总加载时间
    const pageLoadTime = timing.loadEventEnd - timing.navigationStart;

    // DNS 查询时间
    const dnsTime = timing.domainLookupEnd - timing.domainLookupStart;

    // TCP 连接时间
    const tcpTime = timing.connectEnd - timing.connectStart;

    // 服务器响应时间
    const responseTime = timing.responseEnd - timing.requestStart;

    // DOM 加载时间
    const domLoadTime = timing.domComplete - timing.domInteractive;
  })()
</scrpit>
```

## 2、Core Web Vitals - 网页核心性能指标
* google提出 => 可衡量的、能够真实反应用户体验的： 加载、交互、视觉稳定性

### 2.1 LCP - 最大内容渲染 衡量装载性能
* 前2.5s内进行最大内容的渲染
<br></br>

* a. 最大内容包含了哪些?
* * \<img>元素
* * \<svg>元素
* * \<video>元素
* * 通过url()去加载的背景元素
* * 包含文本整体节点的块级元素
<br></br>

* b. LCP值低下的原因
* 服务加载慢
* 阻断渲染的JS
* 资源加载（按需加载）
* 客户端渲染机器性能的影响
<br></br>

* c. 针对性改造
* 服务优化
* * 缓存：HTML离线页面、缓存页面资源、缓存请求
> 面试： 缓存机制

* 资源
* 尽量减少资源加载渲染：CSS和JS做模块集联拆分、内联 & 合并
> 面试：浏览器原理

* 图片、文件格式优化 WEBP => 降低资源大小 => 加快加载速度
* 请求加速 CDN 云服务 => 工程化压缩

## 3、FID 首次输入时延
* 衡量页面的交互性：页面首次输入的延迟应当小于100ms

* a. JS的执行时间过长
* * 缩小并减少JS的体量
* * 延迟后置不必要的JS操作
* * 尽量减少不必要的polyfill
<br></br>

* b.分解耗时的任务
* * 长任务 - 任务阻塞主线程超过50ms的
* * 长任务拆解成较小的异步任务
<br></br>

* c worker
```js
  // main.js
  navigator.serviceWorker.register('./service-worker.js')

  // service-worker.js
  self.addEventListener('install', () => {
      // worker初始化
  })
  self.addEventListener('run', () => {
      // worker执行run命令
  })
  self.addEventListener('push', () => {
      // worker初始化
  })
  self.onmessage = e => {
      // 工作
      self.postMessage(workResult)
  }
```

## 4、 CLS - 布局偏移
衡量视觉问稳定性 => CLS页面应当保持在小于0.1
* 布局的移动在可能发生在可见元素的相邻两帧间的位置 
* a. 不使用无尺寸元素 => srcset sizes 
* b. 减少内容的插入 => 影响整体布局 
* c. 动态字体的控制


## 六、 ⼤⼚可视化性能监控⽅案体系
1、监控SDK - 采集数据
2、数据平台 -数据清洗展示
3、告警运营 - 钉钉 邮件 飞书
4、平台对比 - 放行通知
5、运营看板

性能监控 + 性能调优 + 性能恢复 + 性能优化防劣化