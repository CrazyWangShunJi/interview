## JS 模块化
### 1. 不得不说的历史
#### 背景
JS本身的定位：简单的页面设计 - 页面的逻辑简单处理 + 表单提交以及基本动画
并无模块化 or 命名空间的概念

> JS的模块化需求日益增长

#### 幼年期：无模块化协调阶段
1. 开始需要在页面中增加一些不同的JS：动画、表单、格式化工具
2. 多种js文件被分在不同的文件当中
3. 不同的文件被同一个模块所引用

```js
// index.html
<script src="animation.js"></script>
<script src="mian.js"></script>
<script src="tool.js"></script>
```
认可：
文件分离最基础的模块化，第一步

* 追问：
script标签 - async | defer
```js
// 1. script - 加载 + 解析
// 默认阻塞模式 依赖优先级
<script src="main.js"></script>
// 异步模式 - async   无优先级的大文件
<script src="main.js" async></script>
// 延迟模式 - defer  优先级较低的模块
<script src="main.js" defer></script>
```

问题出现：
* 污染全局作用域 => 不利于大型项目的开发以及多人团队共建


#### 成长期： 模块化的雏形 - IIFE
* 在模块系统尚未成为标准之前，开发者常通过 IIFE 来实现模块化。这种方式**主要通过函数作用域来封装代码**，避免污染全局作用域
例子：
```js
const myModule = (function() {
  const privateVar = 'this is private'
  return {
    getPrivateVar: function() {
      return privateVar
    }
  }
})()

console.log(myModule.getPrivateVar()) // this is private
```
定义函数 + 立即机型 => 独立的空间
初步实现了最最简单的模块
<br></br>

* 追问: **有额外依赖的时候，如何优化 IIFE**
> 优化： 依赖其他模块的IIFE(通过iife的参数来传递依赖)
```js
const iifeModule = ((dependencyModule1, dependencyModule2) => {
  let count = 0

  const obj = {
    increase: () => ++count,
    reset: () => {
        count = 0
    }
  }
  // ...dependencyModule1.xxx, dependencyModule2.xxx
  return obj
})(dependencyModule1, dependencyModule2)
```
* 追问 面试后序引导方向：
    深入模块化的多种方案
    转向框架 - jquery vue react
    转向设计模式 - 注重模块化的设计模式

#### 成熟期
