
# 1 this 概念问题
* 当一个函数被调用时，会创建一个活动记录（有时候也会被称之为执行上下文），这个记录会包含函数在哪里被调用（调用栈）、
函数的调用方法，传入的参数等信息。this就是记录的其中的一个属性，会在函数执行的过程中用到

* this实际上就是函数在被调用时发生的绑定
* this的绑定规则一般有四种


# 2 this 的绑定规则
## 2.1 默认绑定
* 独立函数调用，即直接使用，不加任何修饰（比如被其他对象调用）
* 这个时候，函数里面的this是指向全局对象的
* 当然，如果是严格模式，this会绑定到undefined


## 2.2 隐式绑定
* 当一个对象包含一个指向函数的属性时，并且通过这个属性调用函数，这个时候thisJ就会隐式的绑定到这个对象上面
* 当函数被对象所调用的时候，无论这个对象的引用链有多长，this始终指向最后一次调用它的那个对象

* 隐式丢失，最常见的是回调函数丢失this绑定，当一个函数a作为函数b的参数，并在函数b里面执行时
* 执行时这个函数a其实相当于一个独立函数的调用：
```js
function foo() {
  console.log( this.a );
}
function doFoo(fn) {
  // fn 其实引用的是 foo
  fn(); // <-- 调用位置！
}
var obj = {
  a: 2,
  foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
doFoo( obj.foo ); // "oops, global"
```

# 2.3 显示绑定
* 通过call,apply,bind, 可以函数中的this显示的绑定到对应的对象上面

# 2.4 new
* 当使用new来调用一个函数时，或者说发生构造函数的调用时，会自动执行下面的操作
```
1. 创建（或者说构造）一个全新的对象。
2. 这个新对象会被执行 [[ 原型 ]] 连接。
3. 这个新对象会绑定到函数调用的 this。
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。
```

```js
function foo(a) {
this.a = a;
}
var bar = new foo(2);
console.log( bar.a ); // 2
```